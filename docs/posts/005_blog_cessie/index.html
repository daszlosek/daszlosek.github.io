<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Donald Szlosek">
<meta name="dcterms.date" content="2023-12-30">

<title>szlo.ai - Introduction to the Cessie-Houwelingen Test Statistic</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">szlo.ai</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html" rel="" target="">
 <span class="menu-text">Research</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Introduction to the Cessie-Houwelingen Test Statistic</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">R</div>
                <div class="quarto-category">Statistics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Donald Szlosek </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 30, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>I first read about the Cessie-Houwelingen Test in section 10.5 Assessment of Model Fit from Dr.&nbsp;Frank Harrell’s <a href="https://hbiostat.org/rmsc/"><em>“Regression Modeling Strategies, 2nd Ed.”</em></a> years ago and have always wanted to do more of a deep dive into the inner workings of the test statistic.</p>
<p>S. le Cessie and J. C. van Houwelingen in their 1991 article <a href="https://www.jstor.org/stable/2532385"><em>“A Goodness-of-Fit Test for Binary Regression Models, Based on Smoothing Methods”</em></a> published in <em>Biometrics</em> proposed a global test statistic for logistic regression models. This test has a few other names: le Cessie-van Houwelingen Test, le Cessie-van Houwelingen Normality Test, le Cessie-van Houwelingen goodness of fit Test, and I’m sure a few others. For the sake of brevity, I will be sticking with the Cessie-Houwelingen Test for the rest of this article.</p>
<p><strong>NOTE:</strong> It’s important to distinguish the Cessie-Houwelingen Test from the Cessie-Houwelingen-Copas-Hosmer unweighted sum of squares test, which is a separate method for assessing global goodness of fit. This test, also referred to as the unweighted sum of squares test or the le Cessie-van Houwelingen normal test statistic for the unweighted sum of squared errors, is elaborated upon in the section discussing its historical context. Hosmer (1997) demonstrated through simulations the robustness of this test, and it has been recommended by Harrell for use. It wasn’t until writing this article that I realized they are two separate tests!</p>
<p>The Cessie-Houwelingen Test statistic is essentially a sum of squared standardized residuals post kernel smoothing. The kernel smoothing is particularly important as it accounts for the continuous attributes of covariates, enabling a more detailed and nuanced assessment of how well the model performs (as compared to binning the predictions like in the Hosmer-Lemeshow Test). The essence of this test statistic lies in integrating these refined, smoothed residuals to yield a comprehensive measure of the model’s overall fit.</p>
<p><strong>Calculation Steps</strong></p>
<p>The Cessie-Houwelingen Test Statistic is calculated as follows:</p>
<ol type="1">
<li><p>Standardization of Residuals</p></li>
<li><p>Kernel Smoothing of Residuals</p></li>
<li><p>Adjusting Smooth Residuals by Inverse Variance</p></li>
</ol>
<p>Lets break down each step:</p>
<p><strong>1. Standardization of Residuals</strong></p>
<p>First we need to compute the standardized residuals from the logistic regression model:</p>
<p><span class="math display">\[ r_i = \frac{Y_i - \pi(X_i)}{\sqrt{\pi(X_i)(1 - \pi(X_i))}} \]</span></p>
<p>where <span class="math inline">\(Y_{i}\)</span> are the observed responses, <span class="math inline">\(\pi(X_i)\)</span> are the predicted probabilities from the logistic model and <span class="math inline">\(r_i\)</span> are the standardized residuals.</p>
<p><span class="math inline">\(\pi(X_i)\)</span> is the predicted outputs for the logistic model: <span class="math inline">\(\pi(x) = \frac{e^{\alpha + x\beta}}{1 + e^{\alpha + x\beta}}\)</span></p>
<p>For each observation, the residual is defined as the difference between the observed binary outcome <span class="math inline">\(Y_i\)</span> and the predicted probability <span class="math inline">\(\pi(X_i)\)</span> from the logistic regression model. The difference is then standardized by dividing it by the standard deviation of the predicted probability: <span class="math inline">\({\sqrt{\pi(X_i)(1 - \pi(X_i))}}\)</span>.</p>
<p><strong>2. Smoothing Residuals</strong></p>
<p><span class="math display">\[\hat{r}(x) = \sum_{i=1}^n K_h(x - X_i) r_i\]</span></p>
<p>where <span class="math inline">\(K_h\)</span> is the kernel function with bandwidth <span class="math inline">\(h\)</span>, and <span class="math inline">\(\hat{r}(x)\)</span> are the smoothed residuals. The specific smoothing function used in (Cessie &amp; Houwelingen 1991) was the <a href="https://en.wikipedia.org/wiki/Kernel_regression">Nadaraya-Watson Estimator</a> which is a weighted average of the residuals in the neighborhood of <span class="math inline">\(x\)</span>, where the bandwidth determines the size of the region over which the residuals are averaged and the kernel function determines the weighting. The specific kernel function used in the manuscript (for simplcity?) was the uniform kernel function.</p>
<p>Uniform Kernel Function: <span class="math display">\[ K(x) = \begin{cases} \frac{1}{2} &amp; \text{if } |x| \leq 1, \\ 0 &amp; \text{otherwise.} \end{cases}\]</span></p>
<p><strong>3. Test Statistic</strong></p>
<p><span class="math display">\[T = n \sum_{i=1}^n \hat{r}(X_i)^2 U(X_i)\]</span></p>
<p>with <span class="math inline">\(U(X_i)\)</span> being the inverse of the variance of the smoothed residual at <span class="math inline">\(X_i\)</span> and <span class="math inline">\(n\)</span> is the sample size.</p>
<p>The inverse of the variance is a measure of precision or reliability. It indicates how much we trust the estimate of the smoothed residual at each observation. When squared residuals are weighted by the inverse of their variances, observations with more precise estimates (i.e., lower variance) contribute more to the test statistic, while observations with less precise estimates (i.e., higher variance) contribute less.</p>
<p>The authors mention that each observation contributes to the test statistic <span class="math inline">\(T\)</span> in a way that is <em>proportional</em> to the square of the predicted probability <span class="math inline">\(p(X_i)\)</span> for that observation. Importantly, this contribution is proportional to a factor called <span class="math inline">\(U(X_i)\)</span>, which is the inverse of the variance of the smoothed standardized residual at observation <span class="math inline">\(X_i\)</span>. Thus each observation should contribute to the test statistic in a <em>similar</em> manner. The multiplication of <span class="math inline">\(\hat{r}(X_i)^2\)</span> by <span class="math inline">\(U(X_i)\)</span> scales the contributions of each observation to account for the precision of the smoothed residuals at the observation. Observations with more precise smoothed residuals (lower variance) will have a larger value of <span class="math inline">\(U(X_i)\)</span>, which means their contribution is increased. In contrast observations with less precise smoothed residuals (higher variance) will have a smaller value of <span class="math inline">\(U(X_i)\)</span> and their contribution is decreased.</p>
<p><strong>R Implementation</strong></p>
<p>I discovered a single R implementation of the Cessie-Houwelingen Test in the <a href="https://github.com/USGS-R/smwrStats">smwrStats</a> package, which is now archived. This package was developed by Dr.&nbsp;Laura DeCicco at the United States Geological Survey (USGS). For continuous data, this implementation seems to compute the average of the residuals using Euclidean distance. In contrast, for categorical data, the residuals are calculated using Manhattan distance. Then it appears to use <a href="https://en.wikipedia.org/wiki/Local_regression">local smoothing</a> instead of the Nadaraya-Watson Estimator. The chosen default binwidth is to utilize the mean of the distances as the binwidth when no specific width is specified. Here, I’ve developed a somewhat tidy version of the implementation:</p>
<div class="cell" data-paged.print="false">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">library</span>(<span class="st">"tidyverse"</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">library</span>(<span class="st">"purrr"</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>leCessie_test <span class="ot">&lt;-</span> <span class="cf">function</span>(object, bandwidth) {</span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="co"># Define a function to calculate categorical distances</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  categorical <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb1-8"><a href="#cb1-8"></a>    x <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(x)</span>
<span id="cb1-9"><a href="#cb1-9"></a>    retval <span class="ot">&lt;-</span> <span class="fu">apply</span>(x, <span class="dv">2</span>, <span class="cf">function</span>(y) {</span>
<span id="cb1-10"><a href="#cb1-10"></a>      nrcats <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unique</span>(y))</span>
<span id="cb1-11"><a href="#cb1-11"></a>      <span class="cf">if</span> (nrcats <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb1-12"><a href="#cb1-12"></a>        disty <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">length</span>(y) <span class="sc">*</span> (<span class="fu">length</span>(y) <span class="sc">-</span> <span class="dv">1</span>))</span>
<span id="cb1-13"><a href="#cb1-13"></a>      } <span class="cf">else</span> {</span>
<span id="cb1-14"><a href="#cb1-14"></a>        disty <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">dist</span>(y, <span class="st">'manhattan'</span>) <span class="sc">!=</span> <span class="dv">0</span>) <span class="sc">*</span> nrcats <span class="sc">/</span> (nrcats <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb1-15"><a href="#cb1-15"></a>      }</span>
<span id="cb1-16"><a href="#cb1-16"></a>      <span class="fu">return</span>(disty)</span>
<span id="cb1-17"><a href="#cb1-17"></a>    })</span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="fu">return</span>(<span class="fu">rowSums</span>(retval))</span>
<span id="cb1-19"><a href="#cb1-19"></a>  }</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>  <span class="co"># Store the original object and construct the variable name</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>  object.orig <span class="ot">&lt;-</span> object</span>
<span id="cb1-23"><a href="#cb1-23"></a>  Dname <span class="ot">&lt;-</span> <span class="fu">as.character</span>(object<span class="sc">$</span>call<span class="sc">$</span>formula)</span>
<span id="cb1-24"><a href="#cb1-24"></a>  Dname <span class="ot">&lt;-</span> <span class="fu">paste</span>(Dname[<span class="dv">2</span>], Dname[<span class="dv">1</span>], Dname[<span class="dv">3</span>]) <span class="co"># Arrange variable names in the correct order</span></span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a>  <span class="co"># Calculate fitted values and residuals from the model</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>  fits <span class="ot">&lt;-</span> <span class="fu">fitted</span>(object)</span>
<span id="cb1-28"><a href="#cb1-28"></a>  resids <span class="ot">&lt;-</span> <span class="fu">resid</span>(object, <span class="st">'response'</span>)</span>
<span id="cb1-29"><a href="#cb1-29"></a>  N <span class="ot">&lt;-</span> <span class="fu">length</span>(resids)</span>
<span id="cb1-30"><a href="#cb1-30"></a>  </span>
<span id="cb1-31"><a href="#cb1-31"></a>  <span class="co"># Extract the model frame and check if response is a matrix</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>  obj.frame <span class="ot">&lt;-</span> <span class="fu">model.frame</span>(object)</span>
<span id="cb1-33"><a href="#cb1-33"></a>  <span class="cf">if</span> (<span class="fu">class</span>(obj.frame[[<span class="dv">1</span>]]) <span class="sc">==</span> <span class="st">'matrix'</span>) <span class="fu">stop</span>(<span class="st">"Cannot perform test where response is matrix"</span>)</span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a>  <span class="co"># Calculate distances for each predictor in the model</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>  distances <span class="ot">&lt;-</span> <span class="fu">lapply</span>(obj.frame[,<span class="sc">-</span><span class="dv">1</span>, <span class="at">drop=</span><span class="cn">FALSE</span>], <span class="cf">function</span>(x) {</span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="cf">if</span> (<span class="fu">is.numeric</span>(x)) {</span>
<span id="cb1-38"><a href="#cb1-38"></a>      scaled_x <span class="ot">&lt;-</span> <span class="fu">scale</span>(x)</span>
<span id="cb1-39"><a href="#cb1-39"></a>      dist_x <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">dist</span>(scaled_x))</span>
<span id="cb1-40"><a href="#cb1-40"></a>      <span class="fu">return</span>(<span class="fl">0.5</span> <span class="sc">*</span> dist_x <span class="sc">*</span> dist_x)  <span class="co"># Compute squared Euclidean distance</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>    } <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">class</span>(x) <span class="sc">==</span> <span class="st">'factor'</span>) {</span>
<span id="cb1-42"><a href="#cb1-42"></a>      <span class="fu">return</span>(<span class="fu">categorical</span>(x))  <span class="co"># Use the categorical distance function for factor variables</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-44"><a href="#cb1-44"></a>      scaled_x <span class="ot">&lt;-</span> <span class="fu">scale</span>(x[[<span class="dv">1</span>]])</span>
<span id="cb1-45"><a href="#cb1-45"></a>      dist_x <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">dist</span>(scaled_x))</span>
<span id="cb1-46"><a href="#cb1-46"></a>      <span class="fu">return</span>(<span class="fl">0.5</span> <span class="sc">*</span> dist_x <span class="sc">*</span> dist_x)  <span class="co"># Handle structured variables created from a function</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>    }</span>
<span id="cb1-48"><a href="#cb1-48"></a>  })</span>
<span id="cb1-49"><a href="#cb1-49"></a></span>
<span id="cb1-50"><a href="#cb1-50"></a>  <span class="co"># Initialize a matrix for combined distances and fill it</span></span>
<span id="cb1-51"><a href="#cb1-51"></a>  dist.mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, N, N)</span>
<span id="cb1-52"><a href="#cb1-52"></a>  <span class="cf">for</span> (dist_x <span class="cf">in</span> distances) {</span>
<span id="cb1-53"><a href="#cb1-53"></a>    dist.mat[<span class="fu">lower.tri</span>(dist.mat)] <span class="ot">&lt;-</span> dist.mat[<span class="fu">lower.tri</span>(dist.mat)] <span class="sc">+</span> <span class="fu">sqrt</span>(dist_x[<span class="fu">lower.tri</span>(dist_x)])</span>
<span id="cb1-54"><a href="#cb1-54"></a>  }</span>
<span id="cb1-55"><a href="#cb1-55"></a>  dist.mat <span class="ot">&lt;-</span> dist.mat <span class="sc">+</span> <span class="fu">t</span>(dist.mat)  <span class="co"># Symmetrize the distance matrix</span></span>
<span id="cb1-56"><a href="#cb1-56"></a></span>
<span id="cb1-57"><a href="#cb1-57"></a>  <span class="co"># Set bandwidth if not specified</span></span>
<span id="cb1-58"><a href="#cb1-58"></a>  <span class="cf">if</span> (<span class="fu">missing</span>(bandwidth)) bandwidth <span class="ot">&lt;-</span> <span class="fu">mean</span>(dist.mat)</span>
<span id="cb1-59"><a href="#cb1-59"></a>  R.raw <span class="ot">&lt;-</span> <span class="fu">pmax</span>(<span class="dv">1</span> <span class="sc">-</span> dist.mat <span class="sc">/</span> bandwidth, <span class="dv">0</span>)  <span class="co"># Compute the raw smoother matrix</span></span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a>  <span class="co"># Calculate smoothed residuals and raw Q</span></span>
<span id="cb1-62"><a href="#cb1-62"></a>  smoothres <span class="ot">&lt;-</span> <span class="fu">t</span>(resids) <span class="sc">%*%</span> R.raw</span>
<span id="cb1-63"><a href="#cb1-63"></a>  Q.raw <span class="ot">&lt;-</span> <span class="fu">sum</span>(smoothres <span class="sc">*</span> resids)</span>
<span id="cb1-64"><a href="#cb1-64"></a></span>
<span id="cb1-65"><a href="#cb1-65"></a>  <span class="co"># Prepare matrices for the corrected estimation of Q</span></span>
<span id="cb1-66"><a href="#cb1-66"></a>  obj.mat <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(object.orig)</span>
<span id="cb1-67"><a href="#cb1-67"></a>  mu2 <span class="ot">&lt;-</span> fits <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> fits)</span>
<span id="cb1-68"><a href="#cb1-68"></a>  V <span class="ot">&lt;-</span> <span class="fu">diag</span>(mu2)</span>
<span id="cb1-69"><a href="#cb1-69"></a>  Vx <span class="ot">&lt;-</span> <span class="fu">diag</span>(V)</span>
<span id="cb1-70"><a href="#cb1-70"></a>  obj.hat <span class="ot">&lt;-</span> Vx <span class="sc">*</span> obj.mat <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(obj.mat) <span class="sc">%*%</span> (Vx <span class="sc">*</span> obj.mat)) <span class="sc">%*%</span> <span class="fu">t</span>(obj.mat)</span>
<span id="cb1-71"><a href="#cb1-71"></a>  R.cor <span class="ot">&lt;-</span> (<span class="fu">diag</span>(N) <span class="sc">-</span> obj.hat) <span class="sc">%*%</span> R.raw <span class="sc">%*%</span> (<span class="fu">diag</span>(N) <span class="sc">-</span> obj.hat)</span>
<span id="cb1-72"><a href="#cb1-72"></a></span>
<span id="cb1-73"><a href="#cb1-73"></a>  <span class="co"># Compute corrected estimated value of Q and its standard error</span></span>
<span id="cb1-74"><a href="#cb1-74"></a>  E.Q <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(R.cor) <span class="sc">*</span> mu2)</span>
<span id="cb1-75"><a href="#cb1-75"></a>  mu4 <span class="ot">&lt;-</span> mu2 <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">3</span> <span class="sc">*</span> mu2)</span>
<span id="cb1-76"><a href="#cb1-76"></a>  VarQ1 <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(R.cor)<span class="sc">^</span><span class="dv">2</span> <span class="sc">*</span> (mu4 <span class="sc">-</span> <span class="dv">3</span> <span class="sc">*</span> mu2<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb1-77"><a href="#cb1-77"></a>  R.tmp <span class="ot">&lt;-</span> R.cor <span class="sc">*</span> <span class="fu">matrix</span>(<span class="fu">rep</span>(mu2, <span class="at">each =</span> N), <span class="at">nrow =</span> N)</span>
<span id="cb1-78"><a href="#cb1-78"></a>  VarQ2 <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">sum</span>(<span class="fu">diag</span>(R.tmp <span class="sc">%*%</span> R.tmp))</span>
<span id="cb1-79"><a href="#cb1-79"></a>  VarQ <span class="ot">&lt;-</span> VarQ1 <span class="sc">+</span> VarQ2</span>
<span id="cb1-80"><a href="#cb1-80"></a></span>
<span id="cb1-81"><a href="#cb1-81"></a>  <span class="co"># Calculate the test statistic and degrees of freedom</span></span>
<span id="cb1-82"><a href="#cb1-82"></a>  Test <span class="ot">&lt;-</span> Q.raw <span class="sc">*</span> <span class="dv">2</span> <span class="sc">*</span> E.Q <span class="sc">/</span> VarQ</span>
<span id="cb1-83"><a href="#cb1-83"></a>  df <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> E.Q<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> VarQ</span>
<span id="cb1-84"><a href="#cb1-84"></a></span>
<span id="cb1-85"><a href="#cb1-85"></a>  <span class="co"># Construct the output</span></span>
<span id="cb1-86"><a href="#cb1-86"></a>  output <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">statistic =</span> Test, </span>
<span id="cb1-87"><a href="#cb1-87"></a>             <span class="at">df =</span> df,</span>
<span id="cb1-88"><a href="#cb1-88"></a>             <span class="at">p.value =</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">pchisq</span>(Test, df),</span>
<span id="cb1-89"><a href="#cb1-89"></a>             <span class="at">q =</span> Q.raw, </span>
<span id="cb1-90"><a href="#cb1-90"></a>             <span class="at">e_q =</span> E.Q,</span>
<span id="cb1-91"><a href="#cb1-91"></a>             <span class="at">se_q =</span> <span class="fu">sqrt</span>(VarQ))</span>
<span id="cb1-92"><a href="#cb1-92"></a>  </span>
<span id="cb1-93"><a href="#cb1-93"></a>  <span class="fu">return</span>(output)</span>
<span id="cb1-94"><a href="#cb1-94"></a>  </span>
<span id="cb1-95"><a href="#cb1-95"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then testing it out on the titanic dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>titanic <span class="ot">&lt;-</span> titanic<span class="sc">::</span>titanic_train <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(Survived, Age) <span class="sc">%&gt;%</span> <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(Age))</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a>glm_model <span class="ot">&lt;-</span> <span class="fu">glm</span>(Survived <span class="sc">~</span> Age, <span class="at">data =</span> titanic)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  statistic       df     p.value        q      e_q     se_q
1  20.56367 5.171196 0.001133206 380.1192 95.58951 59.44697</code></pre>
</div>
</div>
<p>A p-value of 0.001133206 in the Cessie-Houwelingen Test strongly suggests that the model does not fit the data well. This result indicates a need to review and potentially revise the model to better capture the underlying relationship in the observed data.</p>
<p>While there might not be alot of implenetations of the Cessie-Houwelingen Test, there are quite a few of the Cessie-Houwelingen-Copas-Hosmer unweighted sum of squares test:</p>
<ul>
<li><code>rms::residuals(rms::lrm(Y ~ X, data = simulated_data, x=TRUE, y=TRUE), type = "gof")</code></li>
<li><code>DescTools::HosmerLemeshowTest(fit)</code></li>
<li><code>MKmisc::HLgofTest(fit)</code></li>
</ul>
<p><strong>A simple explanation of the Cessie-Houwelingen</strong></p>
<p>Thus you can consider the Cessie-Houlingen Test as a comparison of the observed values to the standardized residuals after weighting them by the inverse of the variance of a kernel smoothing function.</p>
<div class="cell">
<style type="text/css">
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 12px;
    border-left: 5px solid #eee;
}
</style>
</div>
<p><strong>Some Historical Context</strong></p>
<p>I believed it would be beneficial to provide a succinct overview of the timeline regarding the development of the Cessie &amp; Houwelingen Statistic in relation to other global goodness-of-fit tests for logistic regression. Please note, this is not a comprehensive historical chronology.</p>
<ul>
<li><p><strong>1980</strong> - Hosmer and Lemeshow introduced a widely-used method for assessing the goodness-of-fit in logistic regression models. This technique involves categorizing data into several groups based on the model’s predicted probabilities and then computing a chi-squared-like statistic.</p></li>
<li><p><strong>1982</strong> - Following this, Brown detailed a goodness-of-fit test for the logistic model based on score statistics. Brown’s approach extends the logistic model to a broader family of models with two additional parameters that, when set to zero, reduce the model to its standard logistic form.</p></li>
<li><p><strong>1983</strong> - Copas later used kernel methods to visually assess the fit of these models.</p></li>
<li><p><strong>1989</strong> - Copas introduced the unweighted sum of squares test for proportions.</p></li>
<li><p><strong>1991</strong> - Cessie &amp; Houwelingen - Modified Copas (1983) to create a weighted sum of squares based on nonparametric kernel methods.</p></li>
<li><p><strong>1995</strong> - Expansion of the Cessie &amp; Houwelingen Test Statistics to allow for unweighted sum of sqaures. - *Note that the unweighted sum of squares test (from Copas 1989) is considered a special case of the series of goodness-of-fit test statistics considered by Cessie and Houwelingen.</p></li>
<li><p><strong>1997</strong> - Hosmer and colleagues compared various goodness-of-fit tests, including the Pearson Chi-Square, Unweighted Sum of Squares (Copas 1989), Hosmer-Lemeshow (C, H), Kernel Smoothing (Uniform and Cubic weighting, Cessie &amp; Houwelingen 1991), Royston (monotone and quadratic), and the Stukel Score Test. <strong>They found the unweighted sum of squares was both simple and powerful.</strong></p></li>
</ul>
<p><strong>Some thoughts</strong></p>
<ul>
<li>Changing Kernel Function and Bandwidth
<ul>
<li><p>In Section 7. Practical Considerations, the authors state:</p>
<ul>
<li><blockquote class="blockquote">
<p>“In the literature of kernel regression and density estimation, it is suggested that the choice of the kernel function is not so important. The simplest kernel to deal with is the uniform kernel on <span class="math inline">\([\frac{1}{2},\frac{1}{2}]\)</span>, which has been used throughout his paper. There is no evidence that a different type of kernel function would alter the result significantly.”</p>
</blockquote></li>
</ul></li>
<li><p>Although I believe this statement to be correct, I noticed that the authors haven’t provided any references to back it up. I’m curious to explore how the test statistic varies with the use of different kernel regressions, specifically Gaussian and Epanechnikov, and also how it’s affected by adjusting the bandwidth of the kernel function.</p></li>
<li><p>Gaussian Kernel Function</p>
<ul>
<li><span class="math inline">\(K(x) = \frac{1}{\sqrt{2\pi}} e^{-\frac{1}{2} x^2}\)</span></li>
</ul></li>
<li><p>Epanechnikov Kernel Function</p>
<ul>
<li><span class="math inline">\(K(x) = \begin{cases} \frac{3}{4}(1 - x^2) &amp; \text{if } |x| \leq 1, \\ 0 &amp; \text{otherwise.} \end{cases}\)</span></li>
</ul></li>
</ul></li>
<li>It would be nice to recreate the results of the Hosmer 1997 paper to show the performance of the Cessie-Houwelingen-Copas-Hosmer unweighted sum of squares test.</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><p>Hosmer, D.W., Hosmer, T. and Lemeshow, S. (1980) A Goodness-of-Fit Tests for the Multiple Logistic Regression Model. Communications in Statistics, 10, 1043-1069. https://doi.org/10.1080/03610928008827941</p></li>
<li><p>Charles C. Brown (1982) On a goodness of fit test for the logistic model based on score statistics, Communications in Statistics - Theory and Methods, 11:10, 1087-1105, DOI: 10.1080/03610928208828295</p></li>
<li><p>Copas, J. B. (1983). Plotting p against x. Journal of the Royal Statistical Society. Series C (Applied Statistics), 32(1), 25–31. https://doi.org/10.2307/2348040</p></li>
<li><p>Copas, J. B. (1989). Unweighted Sum of Squares Test for Proportions. Journal of the Royal Statistical Society. Series C (Applied Statistics), 38(1), 71–80. https://doi.org/10.2307/2347682</p></li>
<li><p>le Cessie, S., &amp; Houwelingen, J.C. (1991). A goodness-of-fit test for binary regression models, based on smoothing methods. Biometrics, 47, 1267-1282.</p></li>
<li><p>le Cessie, S., &amp; van Houwelingen, H. C. (1995). Testing the fit of a regression model via score tests in random effects models. Biometrics, 51(2), 600–614.</p></li>
<li><p>Hosmer, D. W., Hosmer, T., Le Cessie, S., &amp; Lemeshow, S. (1997). A comparison of goodness-of-fit tests for the logistic regression model. Statistics in medicine, 16(9), 965–980. https://doi.org/10.1002/(sici)1097-0258(19970515)16:9&lt;965::aid-sim509&gt;3.0.co;2-o</p></li>
<li><p>Harrell, F. E., Jr.&nbsp;(2016). Regression modeling strategies. Springer International Publishing. 2nd Ed. Section 10.5 Aessment of Model Fit, p.&nbsp;236.</p></li>
</ul>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>